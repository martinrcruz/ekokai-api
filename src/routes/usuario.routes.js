const express = require('express');
const router = express.Router();
const mongoose = require('mongoose');
const usuarioCtrl = require('../controllers/usuario.controller');
const { authMiddleware, permitirRoles } = require('../middleware/auth.middleware');

// Aplica JWT a todas las rutas
router.use(authMiddleware);

// ========================================
// RUTAS ESPEC√çFICAS (DEBEN IR PRIMERO)
// ========================================

// ‚úÖ RUTA DE PRUEBA TEMPORAL
router.get('/test-estado', (req, res) => {
  console.log('üß™ [TEST] Ruta de prueba /test-estado accedida');
  res.json({ message: 'Ruta de prueba funcionando', timestamp: new Date().toISOString() });
});

// ‚úÖ RUTA DE PRUEBA TEMPORAL PARA HISTORIAL (SIN AUTENTICACI√ìN)
router.get('/test-historial/:usuarioId', async (req, res) => {
  try {
    console.log('üß™ [TEST] Ruta de prueba /test-historial accedida para usuario:', req.params.usuarioId);
    const entregaService = require('../services/entregaresiduo.service');
    const canjeService = require('../services/canje.service');
    
    const entregas = await entregaService.obtenerHistorialUsuario(req.params.usuarioId);
    const canjes = await canjeService.obtenerHistorialCanjes(req.params.usuarioId);
    
    res.json({ 
      message: 'Test de historial exitoso',
      entregas, 
      canjes,
      timestamp: new Date().toISOString() 
    });
  } catch (error) {
    console.error('‚ùå [TEST] Error en test-historial:', error);
    res.status(500).json({ error: error.message });
  }
});

// ‚úÖ RUTA DE PRUEBA PATCH TEMPORAL
router.patch('/test-estado', (req, res) => {
  console.log('üß™ [TEST] Ruta de prueba PATCH /test-estado accedida');
  console.log('üß™ [TEST] Body recibido:', req.body);
  res.json({ 
    message: 'Ruta de prueba PATCH funcionando', 
    body: req.body,
    timestamp: new Date().toISOString() 
  });
});

// GET /api/usuarios/buscar-telefono - Buscar usuario por n√∫mero de tel√©fono
router.get('/buscar-telefono', async (req, res) => {
  try {
    const { telefono } = req.query;
    
    if (!telefono) {
      return res.status(400).json({
        success: false,
        mensaje: 'N√∫mero de tel√©fono es requerido'
      });
    }

    const Usuario = require('../models/usuario.model');
    const usuario = await Usuario.findOne({ telefono: telefono });

    if (!usuario) {
      return res.status(404).json({
        success: false,
        mensaje: 'Usuario no encontrado con ese n√∫mero de tel√©fono'
      });
    }

    // No devolver informaci√≥n sensible
    const usuarioLimpio = {
      _id: usuario._id,
      nombre: usuario.nombre,
      apellido: usuario.apellido,
      telefono: usuario.telefono,
      tokensAcumulados: usuario.tokensAcumulados,
      zona: usuario.zona,
      rol: usuario.rol,
      activo: usuario.activo,
      fechaCreacion: usuario.fechaCreacion,
      ultimaConexion: usuario.ultimaConexion
    };

    res.json({
      success: true,
      usuario: usuarioLimpio,
      mensaje: 'Usuario encontrado exitosamente'
    });

  } catch (error) {
    console.error('Error buscando usuario por tel√©fono:', error);
    res.status(500).json({
      success: false,
      mensaje: 'Error buscando usuario',
      error: error.message
    });
  }
});

// ‚úÖ BUSCAR VECINOS - DEBE IR ANTES DE CUALQUIER RUTA CON PAR√ÅMETROS
router.get('/buscar-vecinos', permitirRoles('administrador', 'encargado'), usuarioCtrl.buscarVecinos);

// ‚úÖ REGISTRAR VECINO - DEBE IR ANTES DE CUALQUIER RUTA CON PAR√ÅMETROS
router.post('/registrar', permitirRoles('administrador','encargado'), usuarioCtrl.registrarVecino);

// ‚úÖ REGISTRAR ENCARGADO - DEBE IR ANTES DE CUALQUIER RUTA CON PAR√ÅMETROS
router.post('/registrar-encargado', permitirRoles('administrador'), usuarioCtrl.registrarConRol);

// ========================================
// RUTAS CON PAR√ÅMETROS (DEBEN IR DESPU√âS)
// ========================================

// ADMINISTRADOR lista usuarios
router.get('/', permitirRoles('administrador'), usuarioCtrl.listarUsuarios);

// Historial de usuario espec√≠fico
router.get('/:usuarioId/historial', permitirRoles('administrador', 'encargado'), usuarioCtrl.historialInteracciones);

// GET /api/usuarios/:id/estadisticas-reciclaje - Estad√≠sticas de reciclaje de un usuario
router.get('/:id/estadisticas-reciclaje', async (req, res) => {
  try {
    const { id } = req.params;

    // Verificar que el usuario existe
    const Usuario = require('../models/usuario.model');
    const usuario = await Usuario.findById(id);
    
    if (!usuario) {
      return res.status(404).json({
        success: false,
        mensaje: 'Usuario no encontrado'
      });
    }

    // Obtener estad√≠sticas de canjes de reciclaje
    const CanjeReciclaje = require('../models/canjeReciclaje.model');
    const Trazabilidad = require('../models/trazabilidad.model');

    const [estadisticasCanjes, estadisticasTrazabilidad] = await Promise.all([
      CanjeReciclaje.aggregate([
        { $match: { usuarioId: mongoose.Types.ObjectId(id) } },
        {
          $group: {
            _id: null,
            totalCanjes: { $sum: 1 },
            tokensGenerados: { $sum: '$tokensGenerados' },
            canjesCompletados: {
              $sum: { $cond: [{ $eq: ['$estado', 'completado'] }, 1, 0] }
            },
            canjesFallidos: {
              $sum: { $cond: [{ $eq: ['$estado', 'fallido'] }, 1, 0] }
            },
            ultimoCanje: { $max: '$fechaInicio' }
          }
        }
      ]),
      Trazabilidad.aggregate([
        { $match: { userId: mongoose.Types.ObjectId(id) } },
        {
          $group: {
            _id: '$step',
            count: { $sum: 1 },
            ultimoEvento: { $max: '$timestamp' }
          }
        }
      ])
    ]);

    // Obtener canjes por mes (√∫ltimos 6 meses)
    const seisMesesAtras = new Date();
    seisMesesAtras.setMonth(seisMesesAtras.getMonth() - 6);

    const canjesPorMes = await CanjeReciclaje.aggregate([
      {
        $match: {
          usuarioId: mongoose.Types.ObjectId(id),
          fechaInicio: { $gte: seisMesesAtras }
        }
      },
      {
        $group: {
          _id: {
            a√±o: { $year: '$fechaInicio' },
            mes: { $month: '$fechaInicio' }
          },
          canjes: { $sum: 1 },
          tokens: { $sum: '$tokensGenerados' }
        }
      },
      { $sort: { '_id.a√±o': -1, '_id.mes': -1 } }
    ]);

    const estadisticas = estadisticasCanjes[0] || {
      totalCanjes: 0,
      tokensGenerados: 0,
      canjesCompletados: 0,
      canjesFallidos: 0,
      ultimoCanje: null
    };

    res.json({
      success: true,
      estadisticas: {
        usuario: {
          id: usuario._id,
          nombre: usuario.nombre,
          apellido: usuario.apellido,
          tokensAcumulados: usuario.tokensAcumulados
        },
        reciclaje: {
          ...estadisticas,
          tasaExito: estadisticas.totalCanjes > 0 
            ? ((estadisticas.canjesCompletados / estadisticas.totalCanjes) * 100).toFixed(2)
            : 0
        },
        trazabilidad: estadisticasTrazabilidad,
        historialMensual: canjesPorMes
      },
      mensaje: 'Estad√≠sticas obtenidas exitosamente'
    });

  } catch (error) {
    console.error('Error obteniendo estad√≠sticas de reciclaje:', error);
    res.status(500).json({
      success: false,
      mensaje: 'Error obteniendo estad√≠sticas de reciclaje',
      error: error.message
    });
  }
});

// Cambiar estado de usuario (solo admin)
router.patch('/:id/estado', permitirRoles('administrador'), usuarioCtrl.cambiarEstadoUsuario);

// Obtener usuario por ID
router.get('/:id', permitirRoles('administrador', 'encargado', 'vecino'), usuarioCtrl.obtenerUsuario);

// Actualizar usuario (solo admin)
router.put('/:id', permitirRoles('administrador'), usuarioCtrl.actualizarUsuario);

// Eliminar usuario (solo admin)
router.delete('/:id', permitirRoles('administrador'), usuarioCtrl.eliminarUsuario);

module.exports = router;
